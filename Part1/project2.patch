diff -ruN gem5/src/cpu/pred/BranchPredictor.py gem5-cse-ca/src/cpu/pred/BranchPredictor.py
--- gem5/src/cpu/pred/BranchPredictor.py	2021-01-13 22:54:16.000000000 -0700
+++ gem5-cse-ca/src/cpu/pred/BranchPredictor.py	2021-10-24 18:52:27.726411562 -0700
@@ -75,6 +75,13 @@
     localPredictorSize = Param.Unsigned(2048, "Size of local predictor")
     localCtrBits = Param.Unsigned(2, "Bits per counter")
 
+class GSelectBP(BranchPredictor):
+    type = 'GSelectBP'
+    cxx_class = 'GSelectBP'
+    cxx_header = "cpu/pred/gselect.hh"
+    PredictorSize = Param.Unsigned('1024', "Size of predictor (entries).")
+    PHTCtrBits = Param.Unsigned('2', "Bits per counter.")
+    globalHistoryBits = Param.Unsigned('8', "Bits of the global history.")
 
 class TournamentBP(BranchPredictor):
     type = 'TournamentBP'
diff -ruN gem5/src/cpu/pred/gselect.cc gem5-cse-ca/src/cpu/pred/gselect.cc
--- gem5/src/cpu/pred/gselect.cc	1969-12-31 17:00:00.000000000 -0700
+++ gem5-cse-ca/src/cpu/pred/gselect.cc	2021-10-24 17:59:08.654983000 -0700
@@ -0,0 +1,231 @@
+/*
+ * Rachel White
+ * CSE420
+ * Project 2
+ * 10/24/2021
+ *
+ */
+
+#include "cpu/pred/gselect.hh"
+
+#include "base/bitfield.hh"
+#include "base/intmath.hh"
+#include "debug/GSelect.hh"
+
+GSelectBP::GSelectBP(const GSelectBPParams *params)
+    : BPredUnit(params),
+      globalPredictorSize(params->PredictorSize),
+      globalCtrBits(params->PHTCtrBits),
+      globalCtrs(globalPredictorSize, SatCounter(globalCtrBits)),
+      globalHistory(params->numThreads, 0),
+      globalHistoryBits(params->globalHistoryBits)
+{
+    if (!isPowerOf2(globalPredictorSize)) {
+        fatal("Invalid global predictor size!\n");
+    }
+
+    assert((8 * sizeof(unsigned)) > globalCtrBits);
+    assert((8 * sizeof(unsigned)) > globalHistoryBits);
+
+    // total bits for index to predictor counters
+    // index is n bits from history concatenated with m bits from PC
+    // after PC has been right shifted this->instShiftAmt bits
+    globalPredictorBits = ceilLog2(globalPredictorSize);
+    
+    globalPredictorMask = mask(globalPredictorBits);
+
+    // bits from program counter in branch_addr
+    globalPCBits = globalPredictorBits - globalHistoryBits;
+    if (globalPCBits < 1) {
+        fatal("Invalid program counter bits must be > 0!\n");
+    }
+        
+    // mask for branch_addr after instShiftAmt shift
+    PCMask = mask(globalPCBits);
+
+    if (globalHistoryBits > globalPredictorBits) {
+        fatal("Global history bits too large for global predictor index!\n");
+    }
+    
+    // Set up the global history mask
+    // this is equivalent to mask(log2(globalPredictorSize)
+    globalHistoryMask = mask(globalHistoryBits);
+
+    // Set up historyRegisterMask
+    historyRegisterMask = mask(globalHistoryBits);
+    
+    DPRINTF(GSelect, "index mask: %#x\n", globalPredictorMask);
+    DPRINTF(GSelect, "PC mask: %#x\n", PCMask);
+    DPRINTF(GSelect, "history mask: %#x\n", globalHistoryMask);
+
+    DPRINTF(GSelect, "predictor size: %i\n",
+            globalPredictorSize);
+
+    DPRINTF(GSelect, "PHT counter bits: %i\n", globalCtrBits);
+
+    DPRINTF(GSelect, "instruction shift amount: %i\n",
+            instShiftAmt);
+}
+
+inline
+void
+GSelectBP::updateGlobalHistTaken(ThreadID tid)
+{
+    globalHistory[tid] = (globalHistory[tid] << 1) | 1;
+    globalHistory[tid] = globalHistory[tid] & historyRegisterMask;
+}
+
+inline
+void
+GSelectBP::updateGlobalHistNotTaken(ThreadID tid)
+{
+    globalHistory[tid] = (globalHistory[tid] << 1);
+    globalHistory[tid] = globalHistory[tid] & historyRegisterMask;
+}
+
+void
+GSelectBP::btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+    // Update Global History to Not Taken (clear LSB)
+    globalHistory[tid] &= (historyRegisterMask & ~ULL(1));
+}
+
+bool
+GSelectBP::lookup(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+    bool global_prediction;
+
+    unsigned i = getPredictorIndex(globalHistory[tid], branch_addr);
+    
+    // Lookup in the global predictor to get its branch prediction
+    unsigned counter_val = globalCtrs[i];
+    global_prediction = getPrediction(counter_val);
+
+    // Create BPHistory and pass it back to be recorded.
+    BPHistory *history = new BPHistory;
+    // remember original global history for this thread
+    // prior to speculative update
+    history->globalHistory = globalHistory[tid];
+    // remember the branch prediction
+    history->globalPredTaken = global_prediction;
+    bp_history = (void *)history;
+
+    // Speculative update of the global 
+    // history for this thread.  Will be
+    // corrected in update() or btbupdate()
+    // if needed.
+    if (global_prediction) {
+        updateGlobalHistTaken(tid);
+        return true;
+    } else {
+        updateGlobalHistNotTaken(tid);
+        return false;
+    }
+}
+
+void
+GSelectBP::uncondBranch(ThreadID tid, Addr pc, void * &bp_history)
+{
+    // Create BPHistory and pass it back to be recorded.
+    BPHistory *history = new BPHistory;
+    history->globalHistory = globalHistory[tid];
+    history->globalPredTaken = true;
+    bp_history = static_cast<void *>(history);
+
+    updateGlobalHistTaken(tid);
+}
+
+void
+GSelectBP::update(ThreadID tid, Addr branch_addr, bool taken,
+                  void *bp_history, bool squashed,
+                  const StaticInstPtr & inst, Addr corrTarget)
+{
+    assert(bp_history);
+
+    BPHistory *history = static_cast<BPHistory *>(bp_history);
+
+    // If this is a misprediction, restore the speculatively
+    // updated state (global history register)
+    // and update again.
+    if (squashed) {
+        // Global history restore and update
+        globalHistory[tid] = (history->globalHistory << 1) | taken;
+        globalHistory[tid] &= historyRegisterMask;
+
+        return;
+    }
+
+    // Update the predictor counters with the proper
+    // resolution of the branch. Histories are updated
+    // speculatively, restored upon squash() calls, and
+    // recomputed upon update(squash = true) calls,
+    // so they do not need to be updated.
+    
+    // Calculate the index to the correct counter using the
+    // global history remembered at the start of branch 
+    // prediction in lookup().  This updates the predictor 
+    // counter on which the original prediction was made.  
+    unsigned i = getPredictorIndex(history->globalHistory, branch_addr);
+    
+    // update predictor counter with actual branch taken value    
+    if (taken) {
+        globalCtrs[i]++;
+    } else {
+        globalCtrs[i]--;
+    }
+
+    // Delete history now that we no longer need it.
+    delete history;
+}
+
+void
+GSelectBP::squash(ThreadID tid, void *bp_history)
+{
+    BPHistory *history = static_cast<BPHistory *>(bp_history);
+
+    // Restore global history to state prior to this branch.
+    globalHistory[tid] = history->globalHistory;
+
+    // Delete this BPHistory now that we're done with it.
+    delete history;
+}
+
+GSelectBP*
+GSelectBPParams::create()
+{
+    return new GSelectBP(this);
+}
+
+/** Private functions */
+
+inline
+unsigned
+GSelectBP::getPredictorIndex(unsigned &history, Addr &branch_addr)
+{
+    // The prediction index is the concatenation of n bits
+    // from the global history register and m bits from the
+    // program counter: i = n + m or i = m*bits(n) + n
+    
+    // Extract the global history component.
+    unsigned n = history & globalHistoryMask;
+    
+    // Extract the PC component.
+    unsigned m = (branch_addr >> instShiftAmt) & PCMask;
+    
+    // Concatenate into index and return;
+    return (((m << globalHistoryBits) | n) & globalPredictorMask);
+}
+
+inline
+bool
+GSelectBP::getPrediction(unsigned &count)
+{
+    // Get the MSB of the count
+    return (count >> (globalCtrBits - 1));
+}
+
+
+#ifdef DEBUG
+int
+GSelectBP::BPHistory::newCount = 0;
+#endif
diff -ruN gem5/src/cpu/pred/gselect.hh gem5-cse-ca/src/cpu/pred/gselect.hh
--- gem5/src/cpu/pred/gselect.hh	1969-12-31 17:00:00.000000000 -0700
+++ gem5-cse-ca/src/cpu/pred/gselect.hh	2021-10-24 17:59:05.943029000 -0700
@@ -0,0 +1,153 @@
+/*
+ * Rachel White
+ * CSE420
+ * Project 2
+ * 10/24/2021
+ *
+ */
+
+#ifndef __CPU_PRED_GSELECT_PRED_HH__
+#define __CPU_PRED_GSELECT_PRED_HH__
+
+#include <vector>
+
+#include "base/sat_counter.hh"
+#include "base/types.hh"
+#include "cpu/pred/bpred_unit.hh"
+#include "params/GSelectBP.hh"
+
+/**
+ * Implements a global select (GSelect) branch predictor. It has a global 
+ * predictor, which uses a global history to index into a table of 
+ * counters.
+ */
+class GSelectBP : public BPredUnit
+{
+  public:
+    /**
+     * The default branch predictor constructor.
+     */
+    GSelectBP(const GSelectBPParams *params);
+
+    /**
+     * Takes the given address and returns a true or false value if it is taken
+     * or not taken.
+     * The BPHistory object is to save any state for squash or update.
+     * @param branch_addr The address of the branch to look up.
+     * @param bp_history Pointer that will be set to the BPHistory object.
+     * @return True if taken/False if not taken.
+     */
+    bool lookup(ThreadID tid, Addr branch_addr, void * &bp_history);
+
+    /**
+     * On an unconditional branch, updates the global history.
+     * @param bp_history Pointer for the BPHistory object.
+     */
+    void uncondBranch(ThreadID tid, Addr pc, void * &bp_history);
+
+    /**
+     * Updates the branch predictor to Not Taken if a Branch Target
+     * Buffer (BTB) entry is invalid or not found.
+     * @param branch_addr The address of the branch to look up.
+     * @param bp_history Pointer to any bp history state.
+     */
+    void btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history);
+
+    /**
+     * Updates the branch predictor with the result of a branch.
+     * @param branch_addr The address of the branch.
+     * @param taken T/F whether the branch was taken or not taken.
+     * @param bp_history Pointer to the BPHistory object that was created
+     * during branch prediction.
+     * @param squashed set true when this function is called during a squash.
+     */
+    void update(ThreadID tid, Addr branch_addr, bool taken, void *bp_history,
+                bool squashed, const StaticInstPtr & inst, Addr corrTarget);
+
+    /**
+     * Restores the global branch history to its previous state when a squash
+     * happens.
+     * @param bp_history Pointer to the BPHistory object that contains the
+     * previous global branch history.
+     */
+    void squash(ThreadID tid, void *bp_history);
+
+  private:
+    /**
+     * Returns if the branch should be taken or not, given a counter
+     * value.
+     * @param count The counter value.
+     */
+    inline bool getPrediction(unsigned &count);
+    
+    inline unsigned getPredictorIndex(unsigned &history, Addr &branch_addr);
+
+    /** Updates global history as taken. */
+    inline void updateGlobalHistTaken(ThreadID tid);
+
+    /** Updates global history as not taken. */
+    inline void updateGlobalHistNotTaken(ThreadID tid);
+
+    /**
+     * The branch history information that is created upon predicting
+     * a branch.  It will be passed back upon updating and squashing,
+     * when the BP can use this information to update/restore its
+     * state properly.
+     */
+    struct BPHistory {
+#ifdef DEBUG
+        BPHistory()
+        { newCount++; }
+        ~BPHistory()
+        { newCount--; }
+
+        static int newCount;
+#endif
+        /** This holds a copy of the global history 
+            at start of the branch prediction process
+            in lookup(). */ 
+        unsigned globalHistory;
+        /** The branch prediction made by lookup(). */
+        bool globalPredTaken;
+    };
+
+    /** Number of entries in the global predictor. */
+    unsigned globalPredictorSize;
+    
+    /** Number of bits in the global predictor index. */
+    unsigned globalPredictorBits;
+    unsigned globalPredictorMask;
+
+    /** Number of bits of the global predictor's counters. */
+    unsigned globalCtrBits;
+
+    /** Array of counters that make up the global predictor. 
+        The index for this array is a concatenation of PC 
+        and global history bits. */
+    std::vector<SatCounter> globalCtrs;
+
+    /** Global history register. Contains as much history as specified by
+     *  globalHistoryBits. Actual number of bits used is determined by
+     *  globalHistoryMask. Indexed by Thread ID (TID). */
+    std::vector<unsigned> globalHistory;
+
+    /** Number of bits in the globalCtrs index from the program counter */
+    unsigned globalPCBits;
+    
+    unsigned PCMask;
+    
+    /** Number of bits for the global history. Determines maximum number of
+        entries in global. This is also the number of bits in the 
+        globalsCtrs index from globalHistory. */
+    unsigned globalHistoryBits;
+
+    /** Mask to apply to globalHistory to access global history table.
+     *  Based on globalPredictorSize.*/
+    unsigned globalHistoryMask;
+
+    /** Mask to control how much history is stored. All of it might not be
+     *  used. */
+    unsigned historyRegisterMask;
+};
+
+#endif // __CPU_PRED_GSELECT_PRED_HH__
diff -ruN gem5/src/cpu/pred/SConscript gem5-cse-ca/src/cpu/pred/SConscript
--- gem5/src/cpu/pred/SConscript	2021-01-13 22:54:16.000000000 -0700
+++ gem5-cse-ca/src/cpu/pred/SConscript	2021-10-17 23:17:05.517351483 -0700
@@ -56,8 +56,10 @@
 Source('tage_sc_l.cc')
 Source('tage_sc_l_8KB.cc')
 Source('tage_sc_l_64KB.cc')
+Source('gselect.cc')
 DebugFlag('FreeList')
 DebugFlag('Branch')
 DebugFlag('Tage')
 DebugFlag('LTage')
 DebugFlag('TageSCL')
+DebugFlag('GSelect')
